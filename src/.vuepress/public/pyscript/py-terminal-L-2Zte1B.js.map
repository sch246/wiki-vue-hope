{"version":3,"file":"py-terminal-L-2Zte1B.js","sources":["../src/plugins/py-terminal.js"],"sourcesContent":["// PyScript py-terminal plugin\nimport { TYPES, hooks } from \"../core.js\";\nimport { notify } from \"./error.js\";\nimport { defineProperty } from \"polyscript/exports\";\n\nconst SELECTOR = [...TYPES.keys()]\n    .map((type) => `script[type=\"${type}\"][terminal],${type}-script[terminal]`)\n    .join(\",\");\n\n// show the error on main and\n// stops the module from keep executing\nconst notifyAndThrow = (message) => {\n    notify(message);\n    throw new Error(message);\n};\n\nconst pyTerminal = async () => {\n    const terminals = document.querySelectorAll(SELECTOR);\n\n    // no results will look further for runtime nodes\n    if (!terminals.length) return;\n\n    // if we arrived this far, let's drop the MutationObserver\n    // as we only support one terminal per page (right now).\n    mo.disconnect();\n\n    // we currently support only one terminal as in \"classic\"\n    if (terminals.length > 1) notifyAndThrow(\"You can use at most 1 terminal.\");\n\n    const [element] = terminals;\n    // hopefully to be removed in the near future!\n    if (element.matches('script[type=\"mpy\"],mpy-script'))\n        notifyAndThrow(\"Unsupported terminal.\");\n\n    // import styles lazily\n    document.head.append(\n        Object.assign(document.createElement(\"link\"), {\n            rel: \"stylesheet\",\n            href: new URL(\"./xterm.css\", import.meta.url),\n        }),\n    );\n\n    // lazy load these only when a valid terminal is found\n    const [{ Terminal }, { Readline }, { FitAddon }] = await Promise.all([\n        import(/* webpackIgnore: true */ \"../3rd-party/xterm.js\"),\n        import(/* webpackIgnore: true */ \"../3rd-party/xterm-readline.js\"),\n        import(/* webpackIgnore: true */ \"../3rd-party/xterm_addon-fit.js\"),\n    ]);\n\n    const readline = new Readline();\n\n    // common main thread initialization for both worker\n    // or main case, bootstrapping the terminal on its target\n    const init = (options) => {\n        let target = element;\n        const selector = element.getAttribute(\"target\");\n        if (selector) {\n            target =\n                document.getElementById(selector) ||\n                document.querySelector(selector);\n            if (!target) throw new Error(`Unknown target ${selector}`);\n        } else {\n            target = document.createElement(\"py-terminal\");\n            target.style.display = \"block\";\n            element.after(target);\n        }\n        const terminal = new Terminal({\n            theme: {\n                background: \"#191A19\",\n                foreground: \"#F5F2E7\",\n            },\n            ...options,\n        });\n        const fitAddon = new FitAddon();\n        terminal.loadAddon(fitAddon);\n        terminal.loadAddon(readline);\n        terminal.open(target);\n        fitAddon.fit();\n        terminal.focus();\n        defineProperty(element, \"terminal\", { value: terminal });\n    };\n\n    // branch logic for the worker\n    if (element.hasAttribute(\"worker\")) {\n        // when the remote thread onReady triggers:\n        // setup the interpreter stdout and stderr\n        const workerReady = ({ interpreter, io }, { sync }) => {\n            sync.pyterminal_drop_hooks();\n\n            // This part is inevitably duplicated as external scope\n            // can't be reached by workers out of the box.\n            // The detail is that here we use sync though, not readline.\n            const decoder = new TextDecoder();\n            let data = \"\";\n            const generic = {\n                isatty: true,\n                write(buffer) {\n                    data = decoder.decode(buffer);\n                    sync.pyterminal_write(data);\n                    return buffer.length;\n                },\n            };\n            interpreter.setStdout(generic);\n            interpreter.setStderr(generic);\n            interpreter.setStdin({\n                isatty: true,\n                stdin: () => sync.pyterminal_read(data),\n            });\n\n            io.stderr = (error) => {\n                sync.pyterminal_write(`${error.message || error}\\n`);\n            };\n        };\n\n        // add a hook on the main thread to setup all sync helpers\n        // also bootstrapping the XTerm target on main\n        hooks.main.onWorker.add(function worker(_, xworker) {\n            hooks.main.onWorker.delete(worker);\n            init({\n                disableStdin: false,\n                cursorBlink: true,\n                cursorStyle: \"block\",\n            });\n            xworker.sync.pyterminal_read = readline.read.bind(readline);\n            xworker.sync.pyterminal_write = readline.write.bind(readline);\n            // allow a worker to drop main thread hooks ASAP\n            xworker.sync.pyterminal_drop_hooks = () => {\n                hooks.worker.onReady.delete(workerReady);\n            };\n        });\n\n        // setup remote thread JS/Python code for whenever the\n        // worker is ready to become a terminal\n        hooks.worker.onReady.add(workerReady);\n    } else {\n        // in the main case, just bootstrap XTerm without\n        // allowing any input as that's not possible / awkward\n        hooks.main.onReady.add(function main({ interpreter, io }) {\n            console.warn(\"py-terminal is read only on main thread\");\n            hooks.main.onReady.delete(main);\n            init({\n                disableStdin: true,\n                cursorBlink: false,\n                cursorStyle: \"underline\",\n            });\n\n            // This part is inevitably duplicated as external scope\n            // can't be reached by workers out of the box.\n            // The detail is that here we use readline here, not sync.\n            const decoder = new TextDecoder();\n            let data = \"\";\n            const generic = {\n                isatty: true,\n                write(buffer) {\n                    data = decoder.decode(buffer);\n                    readline.write(data);\n                    return buffer.length;\n                },\n            };\n            interpreter.setStdout(generic);\n            interpreter.setStderr(generic);\n            interpreter.setStdin({\n                isatty: true,\n                stdin: () => readline.read(data),\n            });\n\n            io.stderr = (error) => {\n                readline.write(`${error.message || error}\\n`);\n            };\n        });\n    }\n};\n\nconst mo = new MutationObserver(pyTerminal);\nmo.observe(document, { childList: true, subtree: true });\n\n// try to check the current document ASAP\nexport default pyTerminal();\n"],"names":["SELECTOR","TYPES","keys","map","type","join","notifyAndThrow","message","notify","Error","pyTerminal","async","terminals","document","querySelectorAll","length","mo","disconnect","element","matches","head","append","Object","assign","createElement","rel","href","URL","url","Terminal","Readline","FitAddon","Promise","all","import","readline","init","options","target","selector","getAttribute","getElementById","querySelector","style","display","after","terminal","theme","background","foreground","fitAddon","loadAddon","open","fit","focus","defineProperty","value","hasAttribute","workerReady","interpreter","io","sync","pyterminal_drop_hooks","decoder","TextDecoder","data","generic","isatty","write","buffer","decode","pyterminal_write","setStdout","setStderr","setStdin","stdin","pyterminal_read","stderr","error","hooks","main","onWorker","add","worker","_","xworker","delete","disableStdin","cursorBlink","cursorStyle","read","bind","onReady","console","warn","MutationObserver","observe","childList","subtree","pyTerminal$1"],"mappings":"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"}