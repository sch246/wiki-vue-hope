# 2025-06

::: warning 免责声明

本页面仅代表作者个人观点分享，含有口胡和暴论，不构成任何建议，请谨慎甄别。

:::

## 11

### 学习与实践

> 实践是理论之源，理论从实践中来，目的是应用到实践中去，而学习是联系它们的一种桥梁，学习是人类的天性。
>
> 脱离实践谈理论是无稽之谈，是异化的，是危险的，它会让学习变得让人生厌而提不起兴趣。

### 经验积累

> 人类发展的速度其实和内部之间的信息整合效率有关系，现代互联网解决了流通问题，那么随着信息爆炸，整合问题真正地显露了出来，各个学科可能都能窥见一角真实，而把它们联合成图景却似乎变成了不可能的任务
>
> 我是说，我们需要一个足够稳固的方式，让经验的积累能稳步转换为认知的进步，而无论经验有多么庞大和难以计数。否则整个文明的不同人将不断地做着重复的研究而无法将它们积累贯通起来

### 人贵有自知之明

> 不管干什么都不要紧，重要的是真正清楚自己在干什么，并承担后果

## 19

### 有点意识流了

::: details

左值部分的代码显然不是一般表达式的环境  
而是一种逆转或者镜像的环境  
一般的表达式运行是——从环境中的变量提取值以对表达式求值  
而左值，尤其是解构和模式匹配的左值是——对值解构反函数以取得值赋给环境中的变量  
两者配合以实现了循环  
问题在于，我想要更加精准地控制模式匹配的这种过程，对于每个地方的匹配希望可以定义过滤、分派、绑定  
这似乎不是常规函数定义能做到的  
显然的是，反函数并不是所有函数都有的，因此不是所有函数或者对象都是能解构的  
另一个显然的是，匹配是有可能失败的，因此才有模式匹配  
类型定义是一种可以定义反函数的情况  
假设 int x 可以尝试将 x 转换为 int  
那么  
int x = 2 按照前面的预设解读，就是对 2 运行 int 的逆来获得 x 的绑定  
int 的逆就要求输入一定要是 int，因此如果 2 不是 int 就会匹配失败  
int 的逆没有规定输出，但是从结果来看默认了输出的 x 是 int  
这就是一个过滤和绑定的例子  
另一个过滤和绑定的例子是结构体或者列表解构，与之不同的是可以绑定多个变量，并且其中每个变量可以递归继续进行过滤和绑定  
(a, b) = (1, 2)  
haskell有语法让内部递归绑定的基础上还是可以对整体绑定，，不过感觉看起来不太自然  
但是在这种情况下，如果允许自定义类型等操作，那么int和x都可以是变量，似乎就无法分清哪些是要赋值的内容哪些是要取值的内容了

左值其实是接收值并返回变量绑定的对象，而一般的表达式/代码则是接收变量绑定并返回值的对象  
函数定义后其实就能立马抛出它所捕获的闭包，这也是一个变量绑定  
函数运行完，在结束前也能抛出它运行时的这个环境，也是一个变量绑定，不过我们一般取的是函数运行完所返回的值  
解构不一定成功，因为值不一定是期望的样子，不一定能绑定变量  
其实表达式执行也不一定成功，因为变量环境不一定满足  
只是作用域让变量环境是词法的更好推测了  
而另一面，模式匹配让绑定能匹配多次，函数重载/条件选择也让执行能匹配多次  
变量与值会反复横跳，由变量标识的关系构成了值的结构，然而究其根本这种结构也是由值描述的，这就是结构/代码与数据的同像性  
变量标注了数据流动的结构  
优点是不容易撞名且直观，缺点也是变化太多样且不够有序  
这导致变量本身只能构成扁平无序的结构且只能在作用域内相互关联

函数式代码本身不再隐式包含任何值，而只有如何交互的声明，，这确实比较，，合理，但是也很难按照OOP的思路去做任何事情了，比如创建一个对象，然后修改变量的属性这样  
即使创建了函数闭包，也无法修改闭包内的变量  
而这种可变性的操作只能通过monad或效应处理器解决  
代数效应会把无数的可变交互隔离到纯函数之外，在执行顺序上，纯函数被“效应”切割成了无数块，但每一块依旧是纯的  
于是用函数式语言编写复杂动态代码，实际上需要关注的是“怎么做”，因为除了常量代码不存储任何动态值。。这也是函数式语言最变态的地方

可惜现代计算机从底层就是命令式的，不然函数式还能更厉害一点  
话说虽然OOP很符合直觉，但是里面的概念显得太繁琐了，许多功能都是为了弥补它自身的缺陷而出现的

不可变性引入了创建和销毁开销，作用域的不良设计引入了GC开销，而可变变量会引入并发限制  
我觉得actor模型其实比较有前景，由于actor是分开的所以自然带来了松耦合，能降低心智负担  
思考考首先创建时获取actor能构建actor树  
消息传递引用能构建actor网  
但是actor可能崩溃或消失，因此需要一些定向的发现方式  
每个actor根据自己的类型/名字/tag能属于数个组，并且有组间通信的各种方式，额外的，有方式能够多次跳转几个组在actor之间通信，就和现实的路由器一样

所谓对象，就是定义后立即运行，并抛出变量绑定  
所谓函数，就是定义后捕获闭包，随后可以被运行并返回值

类型取且/或

于是模式匹配应该分为变量绑定，然后再条件判断（guard）  
这种函数声明是什么  
逆向解构结构获得值绑定再顺向建构结构  
确实是单纯的变换

这种变换在声明流程时表现并不好，在这里变得命令式了，而理想的声明应该是设置好依赖关系和触发器，然后自动运行  
依赖关系是：如果要xx，那么必须先xx  
触发器：如果xx，那么xx  
同样构成一正一反  
重要的是，每个信号触发的多个目标操作应该是无序的、平行的，随后为了实现目标操作，能根据依赖自动推导出处理流程，并且在这个过程中继续触发其它操作  
我是不是能理解为，函数定义就是一种特殊的依赖声明，声明了想要做到“函数名”就需要先做“函数体”  
随后通过作用域的变量引用找到其它的依赖  
在运行时则按照定义触发其它的函数


但是这遇到了问题，需要做到“什么”  
这种“什么”的结构依赖于变量绑定，而变量绑定本身很难构成通用的有序结构，比如你知道要按下按钮，但是如果不知道api的具体命名和参数约定，你还是无法调用它  
从另一个角度看编程，实际上是把现实世界的经验，把关系存储在程序里，于是程序能处理现实问题——这意味着必要的关系描述，这种信息是必不可少的  
函数式所做的事情就是通过可读语法尽可能声明一套已知关系，逻辑式编程语言则是打通等价关系，OOP则是构成了一定程度上的有序而减轻了负担，但是它们都有一个限制——一个描述必须人类可读、且程序可读

效应系统还是不太行，它实际上还是在声明当事情触发时的、类似命令式的处理流程，比如网络连接需要先第一步再第二步第三步。。  
这个流程的声明是很死的，需要明确集中声明的  
而如果我想要在流程上进行各种不同的组合，将各种流程像数据一样插入和拼接，就变得困难起来

lisp确实解决了这个问题，但是另一方面lisp对这种流程也没有对应的类型系统

更进一步，编程是一种经验传授，程序员将自己已经知道的信息组织起来输入给计算机，同时也要确保计算机已经组织起来的结构是可查询可理解可执行的  
目前所有的编程语言（至少我了解的）实现这一个目标的方法是用语言规定固定的语法，确保代码能严格描述行为的同时能够被理解和组织，这在方便计算机的同时，给程序员的代码理解能力和信息组织能力提出了高要求，这也是许多代码难以理解、许多代码难以维护的根源  
但是，，要实现这个目标，描述行为并使其可理解和可拓展，并不一定需要用同一个代码同时给计算机和程序员，对于确定的行为描述，计算机总是可以执行的，而程序员只需要可以将自己的经验添加进去就行，它的组织和对程序的影响完全可以是自动的，而程序也只需要能够被查询和理解，让程序员知道如何添加就行，程序员添加行为并不一定需要直接编辑代码  
最重要的也是最困难的是，这个程序本身要能够不断地接收和整合新的经验，而尽可能少地引入维护问题

也就是将，代码对行为的描述，和人类对代码的交互，这两者分离开来  
代码可以以更多的方式被查看和组织，而不只是文本和文件夹，人类对代码的编辑也不是单纯编辑文本，而是使用更加可控和自由的方式进行修改，代码可以暴露更多的操作方式  
可以用更简单的操作进行整合和修改——对代码的交互本身应该也是可编程的

我需要一种通用语言描述标准化的行为，以及描述对代码的交互程序本身，这个交互程序本身应该也能用其进行交互，这是一个相互促进的元领域
:::

## 20

### 编程结构

> 首先，结构要能描述问题和经验  
> 其次，结构要让人便于理解和修改，就不能让人直接看到全貌，而是要能展现灵活的截面  
> 这个截面是以，在一个界面“单次可达”计算的  
> 像笔记软件一样零散、tag和双向引用好像挺好  
> 聚集的方式是tag而不是层级，这是上位替代
>
> 首先肯定是可以在各种截面切换变换的
>
> 人感知什么样的结构最舒服？
>
> 「只让你输入确定的内容，而不是具体实现」
>
> 好的编辑器，首先要能管理资源和笔记
>
> 每种不同类型的关系都构成一个图  
> 引用关系和调用关系？  
> 组间通信  
> 父子关系  
> 「为了更好地描述问题，让我们回到编程的本质  
> 抽象来说，它的本质是什么？  
> 首先，它形成的结构要能描述各种问题和经验，并且准确到计算机可执行  
> 其次，它的结构要让人便于理解和修改  
> 所有的语言、交互、生态、库、抽象层级全都能归结到这两点上  
> 由此推出的第三条公理是，由于事物本身的复杂性和人的认知负荷，不可能在能准确描述问题的同时将全貌展现给人看，因此每次只能展现一个“截面”  
> 这个截面是以，在一个界面开始，“n次可达”来计算的  
> 你可以感觉到这和设计文件系统、资源管理器、编辑器、笔记软件、数据库很有关系  
> 实际上现代代码的类型提示和代码跳转一定程度上起到了管理资源的作用  
> 从抽象的视图看，每种不同类型的关系在所有数据间交织都构成了不同的图，而编辑器一次只能展现少数几种图——在大多数的情况下，编程语言展示的图是父子关系的文件树、词法关系的引用树、以及运行时的调用树，这都是便于人观察结构的“截面”，但是截面肯定不止于此  
> 这指向了，好的编辑器，首先是好的管理资源器和笔记软件——至少我认为好的tag系统是优于现有的文件父子结构的  
> 并且理想情况下，编辑器应该要有能力在不同类型的“截面”之间切换，让人能以自己适应的各种截面进行查看和编辑」

### 移情与抑郁

> 移情是一种边界模糊，本质是猜，多猜多错
>
> 不是说不应该或不需要移情，而是信息不够的情况下移情风险很大
>
> 认为周围人都类似自己是一种移情，将付出视为赎罪是一种移情，认为周围人对自己期望很高也是一种移情
>
> 而抑郁者有时便是因为边界模糊，移情广泛而失去了维持自己的能量
>
> 这往往也体现在抑郁者的家人朋友身上，基于自身焦虑和想象，想要帮助，却帮不上忙甚至帮倒忙

## 22

### 善良不能离开力量，更不能离开清晰

> 而蠢人比坏人破坏力更大，因为蠢人（思想上懒惰）所意识到的现实往往是扭曲的，这让他们的行动失去了保险。

> 人是天然有思想惰性的。而能否克服，就是清晰与模糊的分界线

> 我们重新回到对善良本质的永恒思考上来。
>
> 我不反对心理上的善良应该被倡导
>
> 然而有时越是对方深陷泥潭，盲目去帮忙反倒容易变成自我感动，甚至不如不帮——而这与产生实际帮助的区别就在于是否清晰，是否足够清楚情况的复杂性
>
> 人们常把“心怀善念”“有同情心”本身当作道德成就，仿佛有了这份“心理善良”，就完成了道德义务，甚至获得了某种精神豁免权（“我已仁至义尽”）
>
> 这本质上是**将善良的情感，偷换为善良的实际价值**

> 朋友只是支持性的，许多心结只能自己来解。即使是医生也只能凭借知识与经验，在尽可能柔和的基础上试探，若情况不稳更是抽奖。

> 有时我们所感受到的自己的动机，未必是自己的动机，我们所感受到的世界，未必是真实的世界，大脑会欺骗自己，让我们感受到想要感受到的，于是我们陷入了为自己所编制的梦境之中，而不是所有人都有穿透迷雾，直面本心的勇气和智慧

> *   **戳破自我感动的泡沫**，承认“我的善良可能掺杂私欲”。
> *   **接受认知的局限性**，承认“我对TA和处境的判断可能是错的”。
> *   **承受“不作为”的焦虑**，当“清晰”显示“不帮”比“盲帮”更仁慈时，能克制住干预的冲动。
> *   **直面关系的张力**，当对方拒绝“帮助”或指出伤害时，不将其视为攻击，而是反思的契机。

> 真诚永远比技巧更重要，遇到冲突时能够听到内心感受的成因，而不是受控于情绪下的反应，是一个非常了不起的能力

> 在失去方向之时，真正善良的发心能带我们穿过迷雾——什么是发心？就是念头的起源，动机的开始
>
> 固然善良的心愿未必最后能够达成好的结局，若仅以结果来看，会将这种善良排除在外
>
> 但若善良一开始就不向着产生实际结果去，那么更容易变成灾难式的自我感动，成为人们思想懒惰的借口，仿佛这样做就能够为自己赎罪一般
>
> 真正善良的发心，必然指向以产生实际结果为目标的努力。 这种努力自然导向清晰：会迫使我们更深入地了解情况，更客观地评估自身能力，更清晰地认识到潜在的风险和收益，以确保最终能够落地。

### 罪恶与超越

> 我在玩的《捞女游戏》里遇到了一个困境，女主曾经因为家人生病又误入歧途，加入了“捞女组织”，通过感情诈骗骗取了许多人钱财，现在这些人已经很难找到并挽回了，而女主因缘巧合遇到了她第一个“骗感情”的人，也就是男主，而男主用真心最终也换得了女主的真心，让女主退出了组织并切断了不健康的关系，女主有资格幸福起来吗——即使曾经害了许多人，并且可能无法被取得原谅？
>
> （写到这里为止，只玩到第三章）
>
> 我们先看看 deepseek 的回答：
>
> ::: details
>
> 这个困境触及了人性救赎最核心的悖论——**罪恶的过去是否永久剥夺一个人追求幸福的资格？** 答案并非简单的“是”或“否”，而需要穿透道德审判的表层，审视更深层的伦理维度：
>
> ---
>
> ### **一、不可回避的“罪”与“债”**
> 1.  **客观伤害的沉重性：**
>     她参与的感情诈骗不仅是财产掠夺，更是对受害者情感信任的毁灭性践踏。这种伤害可能导致受害者终身恐惧亲密关系、丧失对人的基本信任。**伤害是真实的，痛苦是具体的。**
> 2.  **“无法挽回”的残酷现实：**
>     受害者难以寻找、经济损失难以弥补、心理创伤难以抚平——这种“不可逆性”是女主必须直面的道德重负。**她永远欠着一笔无法还清的债。**
>
> ---
>
> ### **二、“资格”的本质：谁有权审判？**
> 1.  **外部世界的审判权：**
>     *   **受害者：** 绝对有权不原谅她。他们的愤怒、痛苦是她行为的直接后果，他们的不原谅是正当的自我保护。
>     *   **社会：** 有权谴责其行为，并通过法律（若适用）或道德舆论要求其承担责任。
>     *   **但请注意：** **“是否原谅”是受害者的权利，而“是否有资格幸福”并非由他人全权裁定。** 社会可以惩罚罪行，却无法永久剥夺一个人内在的人性需求。
> 2.  **内在良知的审判权：**
>     女主真正的“资格”挑战源于**自我审判**。若她沉溺于“我不配幸福”的自我惩罚中，本质上仍被过去的罪恶所奴役，未能真正走向新生。
>
> ---
>
> ### **三、救赎的路径：超越“资格”的生存伦理**
> 女主的出路不在于寻求抽象的“幸福资格”认证，而在于以具体行动重构生命意义：
> 1.  **承担“未完成的义务”：**
>     *   **持续弥补：** 即使无法找到所有受害者，也应尽力（如通过公益组织捐助类似受害者、公开警示诈骗手段）。**行动本身是对良知的最低交代。**
>     *   **接受惩罚：** 若法律未追究，她需主动承担某种形式的“自我惩罚”（如长期从事艰苦的公益服务），这不是换取原谅的筹码，而是对罪责的确认。
> 2.  **以“不逃避”代替“自我赦免”：**
>     *   永远承认罪责，不美化过去，不推卸责任（如“我是被迫的”）。将愧疚转化为对他人痛苦的**持续敏感**，而非自我毁灭的燃料。
>     *   **接纳“不被原谅”的可能性：** 这是她必须背负的十字架。真正的救赎是**在知晓不被原谅的前提下，依然选择向善**。
> 3.  **重新定义“幸福”：**
>     *   她的“幸福”注定与常人不同：**不是无忧的甜蜜，而是带着伤疤的平静；不是遗忘的解脱，而是清醒的责任。**
>     *   与男主的真情是救赎的**契机**而非**报酬**。这份感情的价值在于：让她看到人性中仍有值得信任的光明，支撑她走完艰难的赎罪之路。
>
> ---
>
> ### **四、对男主的关键拷问：爱能否成为救赎的基石？**
> 男主的“真心”若要成为救赎力量，而非新的道德陷阱，必须满足：
> 1.  **彻底知情权：** 他是否完全知晓她过去的罪行规模与伤害本质？爱若建立在信息遮蔽上，终将崩塌。
> 2.  **不充当“救世主”：** 他的爱应是**见证者**而非**审判者**或**赦免者**。他无权替受害者原谅她，只能陪伴她面对自身罪责。
> 3.  **支持而非包办赎罪：** 帮助她寻找弥补途径、提醒她勿沉溺于自我感动，而非替她承担道德压力。
>
> ---
>
> ### **结论：在“不配”的阴影下，活出“值得”的姿态**
> *   **法律/社会层面：** 她或许永远无法“清白”，需承担罪责后果（包括潜在的法律风险）。
> *   **道德层面：** 她**没有“理所当然”享受幸福的资格**，但拥有**以血泪浇灌新生、在残缺中重建尊严的权利**。
> *   **存在主义层面：** 她的“幸福”本质是：
>     **在深渊边缘找到一根绳索，明知绳索沾满自己过去的污秽，仍紧握它向上攀爬；
>     在无人喝彩的赎罪路上，为自己点燃一盏不灭的良知之灯；
>     在永远无法偿清的债务中，以余生之力支付微薄的“利息”。**
>
> **她能否幸福？—— 她唯一能做的，是让余生的每一刻都成为对过往罪孽的卑微回应，而非假装无事发生地“拥抱幸福”。若她能做到这点，那么这份沉重却真实的“活着”，便是命运给予她最深刻的慈悲。**
>
> 在游戏这个虚构的伦理实验室中，你们的每一次选择都在叩问：**人性的救赎，究竟需要多少勇气才能背负着不可饶恕的过去，走向未竟的黎明？**
>
> :::
>
> 在承担他人责任的基础上，需要再度承担起自己人生的责任，而这往往在赎罪中被忽略
>
> 我所认同的是，为了对世界产生积极影响，她必须从愧疚情绪中脱离出来，如于断枝之外抽出新芽
>
> 这不是让她否定或者逃避，而是要有勇气承担起更沉重的、所不能逃避的责任。
>
> 自囚于罪孽的牢笼，亦是一种更深层次的逃避。将生命力耗竭在不能改变的事情上，亦是对伤者的亵渎。
>
> 接受所不能改变的，而投入到可以改变的事情之中。
>
> 她现在的生活来源于血泪，而她只能以此尽力活出真正的自己；她必然受其影响，但是不应该受其束缚
>
> ——她可以余生用于他者的情感反诈，但是这不应该是公式化的、出于愧疚、出于补偿的无限赎罪；而是经过深刻反思后，受过影响的自己所选择的方向
>
> ——如果思考得出方向不在于此、她甚至可以选择不这么做——脱出束缚的选择比起苦行僧式的赎罪更加沉重
>
> 而这与逃避的区别在于，清醒知道自己在做什么的人，外界的非议、质疑与冲击不再能动摇她的心境；与麻木僵硬的区别在于，她仍然保留柔软和丰富的体验和反应，不会因内在的坚定而傲慢
>
> **清醒的维度：**
> - **对自身历史的完全接纳：** 不美化、不夸大，将过去视为构成现在的重要元素。
> - **对外界反应的超然：** 理解批评、质疑的合理性，但不被其左右。她的行动指南来自内在的价值体系，而非外在的认可度。
> - **对选择后果的承担：** 无论选择什么路径，都准备承受相应的代价，不抱怨、不后悔。
>
> **柔软的维度：**
> - **对他人痛苦的敏感保持：** 经历过伤害他人的她，反而拥有了识别和理解痛苦的特殊能力。
> - **对新经验的开放：** 不因过去的阴霾而关闭心门，仍能感受爱、友谊、美、希望。
> - **对自我认知的持续更新：** 承认理解是流动的，随时准备调整方向。

> 接受永远的憎恶，但拒绝被憎恶吞噬，如同树木承受斧痕继续生长。

## 25

### 反思

> 上面本质上是活在当下的应用：感受当下，去做能做到的事情

> 不过，如果没有太严重的后果还好说，但是如果是非常极端的情况，那又怎么承受得住呢(建设性新生与毁灭性正义的冲突)
>
> 再怎么说都是逃避
>
> 毕竟从社会视角上看，比起加害者，始终应该是受害者更值得同情，而通过合法但不道德手段获取的利益，始终不应该被鼓励
>
> 加害者应该被惩罚，但是当这个惩罚合理但非法的时候，应该怎么办呢

> 道德和法理上，惩罚是有必要的，只有犯错了难以挽回，后果严重，影响久远，才能有效地震慑潜在的加害者，阻止更多悲剧的发生
>
> 但前提是这个过程要合法
>
> 当道德正义与程序正义相冲突时，应该被修正和完善的是法律；但行动上，则需要坚决维护程序正义，否则会带来更严重的滑坡
>
> 否则这是对社会契约的破坏，将会瓦解法律作为唯一合法暴力垄断者的地位；而法律屏障的破坏导致的是私权、分裂和混乱，伤害的只会是更多弱者
>
> 此时更有建设性的做法是，首先致力于在法治框架内找到尽可能完善的解决方案，其次推行法律完善

> 不过无论社会如何，当冲突产生时，她始终是有权利自我保护的（怼不怼得过另说）。

> 始终记住，“以眼还眼，以牙还牙”（尤其是私刑）虽然符合正义，但是没有建设性，往往导致伤害传递，仇恨蔓延，罪恶泛滥；而法律就是用于斩断链条的

> 法律在设计和实施时也本来就不应该假设所有人都会认同、完全服从、没有阻力的

> 这个图景的终极样貌可能是：加害者推动法律发展，让受害者可以起诉自己，最后成功把自己送进监狱.jpg

## 27

### 交互式编程

未来的编程范式是什么样的？

为了回答这个问题，我们需要意识到编程范式的固有矛盾。

- 机器的精确性 vs. 人类的认知局限。
  - 任何复杂问题都具有本质复杂度，机器执行要求极致精确，因此任何复杂问题的描述都需要有结构的大量信息。然而，人类认知负荷决定了我们一次只能处理有限且相关的信息，为了处理足够复杂的结构，只能从一小部分“截面”去认知和编辑庞大的整体，并通过信息之间的关联层层跳转到不同的截面以得到整体认知。当前的文件系统、变量命名等都是这一矛盾的体现。
  - 文件系统的树形结构是一个反例，仅父子的文件系统实际上引入了额外的管理复杂度，许多现实问题都不能归纳为单纯的父子架构，这导致需要在文件系统中引入额外的复杂性，基于tag的文档系统在这方面就优于它，但是也难说是不是终极解决方案
- 思维流与结构化的矛盾。
  - 高可维护性的代码要求有序的、结构化的表达。然而人类的思维是散乱的、非线性的。现有的编程范式迫使程序员在思维阶段就进行大量组织和转化，提取出结构化的内容，这需要相当的训练并受到固定范式限制。
  - 编程的过程就是不断地从不确定的思维中提取出确定性的内容，并以有序依赖的关系记录到结构之中，这是一种人机之间的“经验传授”。

因此我认为未来的编程语言不应该仅是描述逻辑本身，而是应该是一种与现有结构交互的语言，于是确保能积累任何散乱的经验，但是本身结构保持清晰。

- 我认为人类最易读的结构并不是文本，而是可以交互式的网状结构。这在结构化的同时也是最易于学习和编辑的形式。

因此其终极形态，将是一种交互式的有序网状结构，而非传统的文本。

其内容大体上分为两种类别：

- 基石：无条件的、无依赖的、确定性的内容；
- 衍生：有条件的、依赖性的、不确定性的内容。

当然，对于任何具体的对象而言，无依赖是不可能的，但是对于一个项目来说，总是有能确定的、根本性的基石，而所有内容从这些基石递进地、依赖地衍生出来，直接或间接地依赖于这些内容。

而衍生是**递进的**，随着依赖层级的加深，其不确定性也愈发增大。

编程环境永远应该鼓励程序员只输入确定性的内容(于当前依赖层级下)，因为**确定性内容不占用认知负载，占用认知负载的永远是不确定的内容；不确定性最大的末端，便是创造和编辑的焦点和截面**，并源源不断地从中提取和转换出确定性的内容。

在现在，这种辅助来源于编译前检查，文件结构本身，异常和错误，更多的是语法本身所塑造的思维方式让人从自己的思维提取确定性内容

确定性的基石和确定性的依赖关系构成了依赖网，这是程序本身精确性的一种替换。

任何被依赖对象的修改都可能影响其下游的所有对象，因此修改频率应当从截面到基石逐级递减，这亦应当是语言和交互设计的参考依据。

而很显然的，基石也分为两种：

- 一种是它所依赖的底层环境、抽象层级、库和api，它是自下而上的；
- 一种是全局性的、业务性的指导、想法、要求，它是自上而下的。

**从底层最小砖块开始，其依赖层层递进；从顶层最大目标开始，其分治亦层层递进；代码于其相交之处产生行为。**

这让我想到了**万物负阴而抱阳，冲气以为和**。

我们可以得到如下抽象：

**无极生太极：**

在一切的开始，接收到的只有数据，而不能从其中得到任何信息，此为无极。

为了能够得到信息，我们需要能够判断数据A是否是B，于是能识别并进行操作，这就是**相**，也可以理解为**类型**，其本质是一个布尔函数，作用就是判断一段数据是否满足条件。

需要注意的是相比常规意义上的类型更广泛；它不光界定一类对象，也界定一个对象。因为任何物体本质上都是不断变化而没有明确边界的（例如组成一个水杯的原子本身每时每刻都在变化），**相**对物体进行标识和分别，而让我们能确定这是一个物体。

于是首先，诞生了太极，其大无外，其小无内，一体两面：

- top(有)：万物的并，让所有对象都符合它的条件，它包含所有对象，是无限大的，所有对象的父集（全集），但是对应的，它本身（条件本身）不能包含任何信息，才能任何对象都能符合条件。
- bottom(无)：万物的交，让所有对象都不符合它的条件，它不包含任何对象，是无限小的，所有对象的子集（空集），但是对应的，它本身（条件本身）包含所有信息，才能任何对象都不能满足条件。

如何理解条件本身包含的信息？

因为信息意味着限制条件，是描述，同时也是定位。

比如我定义一个类为 Foo ，它有一个 bar 方法，那么只有一个有 bar 方法的对象才属于这个类。

这个类包含的属性和方法越少，条件越宽泛，那么它所能包含的对象就越多，定位越宽泛；如果这个类没有任何属性和方法，那么所有对象都可以属于这个类。

这个类包含的属性和方法越多，条件越具体(例如依赖类型)，那么它所能包含的对象就越少，定位越精确，甚至指向具体一个值——此时信息就是这个值的描述；如果更进一步，条件产生了矛盾，那么实际上它是没有对象的，所有对象都不可能属于这个类。可以认为这个类包含了所有属性和方法的限制。

为什么可以这样认为？因为即使是施加了最普通的条件限制，其实也可能是包含了无限个更为宽松的限制的，只是不会写出来，那么当限制到没有任何对象能满足时，自然可以认为包含了所有限制。

一切对象与 top 的交依旧是这个对象，与 bottom 的交便是 bottom 本身；与 top 的并是 top 本身，而与 bottom 的并是对象本身。

于是 top 和 bottom 成为了两极，分别对应有和无，通过 not 连接，而在信息上是等价的。

**太极生两仪：**

但是光这样想，也没有太大的实际用处，因为它们不包含任何信息而不可捉摸；

所以使用在局部的具体情形：对于一个具体项目(相)而言，阳极是最顶层的目标(整体描述)，而阴极是最底层的实现(底层基础api)，比太极次一级，乃是两仪。

- **阳**：顶层目标与宏观指导（自上而下，集中而影响深远）
  - 本质与形态： 无依赖的初始想法、宏观指导，以及项目或系统的根源性、指导性文档。由一点（宏观目标）散发出依赖树。
  - 定位与认知： 最容易定位，上下文极少（因为它就是源头），在抽象层面上最为集中，而影响范围最大。它是项目或系统的入口，也是最容易阅读和理解的部分。
  - 生长方向：向下生长。这是分而治之的过程，将抽象的想法渐渐分解为更具体、可执行的计划。
- **阴**：底层实现与最小砖块（自下而上，原子而数量庞大）
  - 本质与形态： 无依赖的公理、最小砖块，无条件、确定性的底层环境、抽象层级、库和api。由无数点（具体实现或依赖）网状收敛于更高的抽象层级。
  - 定位与认知： 最难定位（因为数量庞大且局部），虽然单个信息量少，但总体信息量最大。它们是具体而原子性的存在，往往是繁杂而散乱的集合，不适宜作为理解系统的入口，但却是具体执行的基石。
  - 生长方向：向上生长。这是构建抽象层级的过程，通过封装底层的复杂性并设计接口，形成底层库和封装的类、函数。

注意到这个理论对于现今编程范式的应用：

任何一段代码的运行，都基于外界的引用环境（代码定义时所依赖的对象），以及实际的调用环境（包括动态作用域、输入输出、流程控制等）。

实际上，任何代码的作用都是组织和连接这两个外界。而代码编辑的高峰，或者说这种连接的最核心体现，就是在函数上。

函数生命周期包含了定义和调用两个行为，定义和调用的环境相互独立，且在函数内部产生交织：

- **函数定义(阴)**：在**词法作用域**上引用对象，抽象层级自下而上形成了引用网收敛到了不同函数中。
  - 每次封装底层的复杂性并且设计接口制作库，都是阴的向上生长，并形成底层库和封装的函数。
- **函数调用(阳)**在**调用树**上输入输出对象和进行流程控制，程序逻辑自上而下形成了调用树分散到了不同函数中。
  - 每次对整体任务分而治之，将抽象想法变得渐渐具体和可执行，都是阳的向下生长，并形成流程控制和调用树。

于是函数自然成为了把它们拧一起的节点，**函数定义就是阴，函数调用就是阳**，成为了不确定性的截面；允许程序员通过编辑函数来表示逻辑。

孤阳不生，孤阴不长。现代的编程环境整体是偏阴的，调用树往往并不能承载完整的宏观意图，而需要大量的注释和文档辅助。

**两仪生四象：**

- 少阴（阳中之阴）： 允许函数调用时动态定义函数，产生闭包，继而产生了美妙的对称性。这体现了函数引用的内容可以来自于运行时环境，是阳（调用/运行时）中包含的阴（定义/引用）。
- 少阳（阴中之阳）： 允许函数定义时动态调用函数，例如Lisp的宏系统。这体现了阴（定义/编译时）中包含的阳（调用/执行）。

于是我们继续设计系统。

**存储与阅读**

- 程序中存储的本质不再是传统的代码块，而是确定性的依赖关系。这些关系精确地定义了程序内部的联系和依赖，替代了传统编程语言中由变量、类型、函数定义等带来的精确性。不光包含自下而上的依赖，也包含自上而下的分治。
- 在阅读代码的时候，始终按照从阳到阴的顺序组织结构，并控制每一层级展开的数量。

**变量名的问题**

- 变量名首先是高度非结构化的
  - 这与直觉相反，程序本身并不能从变量名得出几乎任何结构化的信息，而只能从相同变量出现在不同地方这一点上面得到信息
  - 这种有序性甚至比不上列表
  - 甚至名字本身带来的信息对人类引入了更多的认知负荷，因为它除了更易读之外对程序逻辑性并没有实际帮助，从这个角度看是冗余信息
  - 而命名空间就是为了解决变量冲突并增加有序性而引入的

- 逻辑可以基于唯一的标识符，并通过节点之间的确定性关系来定位和理解。例如，一个概念可以有多个文本化的“名字”节点，但它们都连接到同一个核心概念节点。这使得内容可以更灵活地被引用和理解。
  - 对于一个变化的对象如何被准确地判定可以考虑人类是怎么在认知中构建“相”的

**只展示“不确定的内容”**

- 所有确定性的、被依赖的、固定的内容，若与当前截面不直接相关，无需显示任何信息，甚至无需透露其存在。
- 只有不确定的、需要创造或编辑的内容才会被作为“截面”展示出来。
- 编辑从顶层目标开始，随后截面只聚焦于当前所关心的信息，让程序员的注意力聚焦在真正需要思考和修改的地方。
- 当前所看到的“截面”本身就是一个“条件”。它只会显示在当前关注条件下的不确定内容。
- 每次用户在网状结构中进行“跳转”时，都会影响当前截面展示的条件，从而实现类似文件系统或语义跳转的效果，但这一切都是基于关系的。
  - 在现有代码框架下就好像我们不需要知道调用的api具体怎么实现的一样

**个性化与交互的艺术**

- 同一个逻辑和底层结构，在不同人看来可以有不一样的表现方式。每个人可以个性化其交互方式，甚至用系统本身来设计与它交互的逻辑。
- 这使得编程成为一种交互的艺术：使用者根据自己的意图不断地与计算机交互，并见证其反应，减少阻力。
- 使用者应当只需要做最少的而确定性的事情
- 所有的散乱的想法有地方可以放置，并且可以被有效地组织起来
- 系统应当智能提示空缺和需要重构的地方，以进一步减少认知负载。
